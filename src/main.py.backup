#!/usr/bin/env python3
"""GoHighLevel MCP Server using FastMCP"""

import asyncio
import os
import sys
from typing import Optional, Dict, Any, List

from fastmcp import FastMCP
from pydantic import BaseModel, Field

from .api.client import GoHighLevelClient
from .services.oauth import OAuthService
from .services.setup import StandardModeSetup
from .models.contact import ContactCreate, ContactUpdate
from .models.conversation import (
    ConversationCreate,
    MessageCreate,
    MessageStatus,
    MessageType,
)
from .models.opportunity import (
    OpportunityCreate,
    OpportunityUpdate,
    OpportunityStatus,
    OpportunitySearchFilters,
)
from .models.calendar import (
    AppointmentCreate,
    AppointmentUpdate,
)


async def startup_check_and_setup():
    """Check authentication status and run setup if needed"""
    from pathlib import Path

    print("üîß Basic Machines -> GoHighLevel MCP Server")
    print("   Version 0.1.0")

    async with StandardModeSetup() as setup:
        # Check if this is first run
        if setup.is_first_run():
            # First run - let user choose mode
            chosen_mode = setup.choose_auth_mode()

            if chosen_mode == "custom":
                # Custom mode chosen - save this choice and run interactive setup
                setup.save_custom_mode_choice()
                custom_setup_success = await setup.interactive_custom_setup()
                setup.mark_first_run_complete()

                if custom_setup_success:
                    # Credentials collected and .env created, clear the choice marker
                    setup.clear_custom_mode_choice()
                    # Jump directly to Claude Desktop instructions (skip wizard)
                    # Continue to show Claude Desktop instructions section
                else:
                    # User needs to create app first or cancelled
                    # Keep the choice marker so they continue with custom mode on restart
                    return "exit_after_custom_instructions"
            else:
                # Standard mode chosen - continue with setup
                print("üìã Continuing with Standard Mode setup...\n")

                # Standard mode setup wizard
                setup_success = await setup.interactive_setup()

                if not setup_success:
                    print("‚ùå Setup was not completed successfully.")
                    print(
                        "   The MCP server cannot start without valid authentication."
                    )
                    print("   Please run the server again to retry setup.\n")
                    return False

                # Standard setup completed successfully, continue to Claude instructions
        else:
            # Not first run - check existing auth status
            auth_valid, message = setup.check_auth_status()

            if auth_valid:
                # Validate existing config with API
                print(f"‚úÖ {message}")
                print("üîç Validating configuration with Basic Machines...")

                config_valid = await setup.validate_existing_config()
                if config_valid:
                    print("‚úÖ Configuration validated successfully!")
                    return True
                else:
                    print("‚ö†Ô∏è  Configuration validation failed.")
                    print("   Your setup token may have expired or become invalid.")
                    print("üöÄ Re-running setup wizard...\n")

            # Run setup wizard based on current mode
            auth_valid, message = setup.check_auth_status()

            # Check if we're in custom mode (has .env file OR user previously chose custom)
            if setup.env_file.exists() or setup.was_custom_mode_chosen():
                # Custom mode - re-run custom setup
                print("üîß Re-running Custom Mode setup...\n")
                custom_setup_success = await setup.interactive_custom_setup()

                if custom_setup_success:
                    # Clear the choice marker since setup is now complete
                    setup.clear_custom_mode_choice()
                    # Continue to show Claude Desktop instructions
                else:
                    return "exit_after_custom_instructions"
            else:
                # Standard mode - run standard setup
                print("üìã Running Standard Mode setup...\n")
                setup_success = await setup.interactive_setup()

                if not setup_success:
                    print("‚ùå Setup was not completed successfully.")
                    print(
                        "   The MCP server cannot start without valid authentication."
                    )
                    print("   Please run the server again to retry setup.\n")
                    return False

        # Setup completed successfully - show Claude Desktop instructions
        print("\n" + "=" * 60)
        print("üéØ Next Step: Configure Claude Desktop")
        print("=" * 60)

        # Check for virtual environment
        venv_path = Path(os.getcwd()) / ".venv"
        if venv_path.exists():
            python_path = str(venv_path / "bin" / "python")
        else:
            python_path = "python"
            print("\n‚ö†Ô∏è  Warning: No .venv directory found.")
            print("   Make sure you have installed requirements:")
            print("   python -m venv .venv")
            print(
                "   source .venv/bin/activate  # On Windows: .venv\\Scripts\\activate"
            )
            print("   pip install -r requirements.txt")

        print("\nüìã Add this server to Claude Desktop:")
        print("\n1. Open Claude Desktop settings")
        print("2. Navigate to 'Developer' ‚Üí 'Edit Config'")
        print("3. Add the following to your mcpServers configuration:")
        print(
            f"""
{{
  "mcpServers": {{
    "ghl-mcp-server": {{
      "command": "{python_path}",
      "args": [
        "-m",
        "src.main"
      ],
      "cwd": "{os.getcwd()}",
      "env": {{
        "PYTHONPATH": "{os.getcwd()}"
      }}
    }}
  }}
}}
"""
        )
        print("4. Save the configuration and restart Claude Desktop")
        print("\n‚úÖ Your GoHighLevel MCP server is now configured!")

        # Exit after successful setup
        return "exit_after_setup"


# Initialize FastMCP server
mcp: FastMCP = FastMCP(
    name="ghl-mcp-server",
    version="0.1.0",
    description="MCP server for GoHighLevel API v2 integration",
    dependencies=["httpx", "pydantic", "python-dotenv"],
)

# Global clients - will be initialized after startup check
oauth_service: Optional[OAuthService] = None
ghl_client: Optional[GoHighLevelClient] = None


def initialize_clients():
    """Initialize OAuth service and GHL client after setup"""
    global oauth_service, ghl_client
    oauth_service = OAuthService()
    ghl_client = GoHighLevelClient(oauth_service)


# Tool Models


class CreateContactParams(BaseModel):
    """Parameters for creating a contact"""

    location_id: str = Field(
        ..., description="The location ID where the contact will be created"
    )
    first_name: Optional[str] = Field(None, description="Contact's first name")
    last_name: Optional[str] = Field(None, description="Contact's last name")
    email: Optional[str] = Field(None, description="Contact's email address")
    phone: Optional[str] = Field(None, description="Contact's phone number")
    tags: Optional[List[str]] = Field(None, description="Tags to assign to the contact")
    source: Optional[str] = Field(None, description="Source of the contact")
    company_name: Optional[str] = Field(None, description="Contact's company name")
    address: Optional[str] = Field(None, description="Contact's street address")
    city: Optional[str] = Field(None, description="Contact's city")
    state: Optional[str] = Field(None, description="Contact's state")
    postal_code: Optional[str] = Field(None, description="Contact's postal code")
    custom_fields: Optional[Dict[str, Any]] = Field(
        None, description="Custom field values"
    )
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class UpdateContactParams(BaseModel):
    """Parameters for updating a contact"""

    contact_id: str = Field(..., description="The contact ID to update")
    location_id: str = Field(
        ..., description="The location ID where the contact exists"
    )
    first_name: Optional[str] = Field(None, description="Contact's first name")
    last_name: Optional[str] = Field(None, description="Contact's last name")
    email: Optional[str] = Field(None, description="Contact's email address")
    phone: Optional[str] = Field(None, description="Contact's phone number")
    tags: Optional[List[str]] = Field(None, description="Tags to assign to the contact")
    company_name: Optional[str] = Field(None, description="Contact's company name")
    address: Optional[str] = Field(None, description="Contact's street address")
    city: Optional[str] = Field(None, description="Contact's city")
    state: Optional[str] = Field(None, description="Contact's state")
    postal_code: Optional[str] = Field(None, description="Contact's postal code")
    custom_fields: Optional[Dict[str, Any]] = Field(
        None, description="Custom field values"
    )
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class DeleteContactParams(BaseModel):
    """Parameters for deleting a contact"""

    contact_id: str = Field(..., description="The contact ID to delete")
    location_id: str = Field(
        ..., description="The location ID where the contact exists"
    )
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class SearchContactsParams(BaseModel):
    """Parameters for searching contacts"""

    location_id: str = Field(..., description="The location ID to search contacts in")
    query: Optional[str] = Field(None, description="Search query string")
    email: Optional[str] = Field(None, description="Filter by email address")
    phone: Optional[str] = Field(None, description="Filter by phone number")
    tags: Optional[List[str]] = Field(None, description="Filter by tags")
    limit: int = Field(100, description="Number of results to return", ge=1, le=100)
    skip: int = Field(0, description="Number of results to skip", ge=0)
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class GetContactParams(BaseModel):
    """Parameters for getting a single contact"""

    contact_id: str = Field(..., description="The contact ID to retrieve")
    location_id: str = Field(
        ..., description="The location ID where the contact exists"
    )
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class ManageTagsParams(BaseModel):
    """Parameters for managing contact tags"""

    contact_id: str = Field(..., description="The contact ID")
    location_id: str = Field(
        ..., description="The location ID where the contact exists"
    )
    tags: List[str] = Field(..., description="Tags to add or remove")
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


# Conversation Tool Models


class GetConversationsParams(BaseModel):
    """Parameters for getting conversations"""

    location_id: str = Field(..., description="The location ID")
    contact_id: Optional[str] = Field(None, description="Filter by contact ID")
    starred: Optional[bool] = Field(None, description="Filter by starred status")
    unread_only: Optional[bool] = Field(
        None, description="Only show unread conversations"
    )
    limit: int = Field(100, description="Number of results to return", ge=1, le=100)
    skip: int = Field(0, description="Number of results to skip", ge=0)
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class GetConversationParams(BaseModel):
    """Parameters for getting a single conversation"""

    conversation_id: str = Field(..., description="The conversation ID")
    location_id: str = Field(..., description="The location ID")
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class CreateConversationParams(BaseModel):
    """Parameters for creating a conversation"""

    location_id: str = Field(..., description="The location ID")
    contact_id: str = Field(..., description="The contact ID")
    message_type: Optional[str] = Field(
        None,
        description="Initial message type: SMS, Email, WhatsApp, IG, FB, Custom, Live_Chat",
    )
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class GetMessagesParams(BaseModel):
    """Parameters for getting messages in a conversation"""

    conversation_id: str = Field(..., description="The conversation ID")
    location_id: str = Field(..., description="The location ID")
    limit: int = Field(100, description="Number of results to return", ge=1, le=100)
    skip: int = Field(0, description="Number of results to skip", ge=0)
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class SendMessageParams(BaseModel):
    """Parameters for sending a message"""

    conversation_id: str = Field(..., description="The conversation ID")
    location_id: str = Field(..., description="The location ID")
    message_type: str = Field(
        ...,
        description="Type of message to send: SMS, Email, WhatsApp, IG, FB, Custom, Live_Chat",
    )
    contact_id: str = Field(..., description="Contact ID to send message to")

    # SMS fields
    message: Optional[str] = Field(None, description="Message content for SMS")
    phone: Optional[str] = Field(None, description="Phone number for SMS messages")

    # Email fields
    html: Optional[str] = Field(None, description="HTML content for email messages")
    text: Optional[str] = Field(
        None, description="Plain text content for email messages"
    )
    subject: Optional[str] = Field(None, description="Subject line for email messages")

    # General
    attachments: Optional[List[Dict[str, Any]]] = Field(
        None, description="Optional attachments"
    )
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class UpdateMessageStatusParams(BaseModel):
    """Parameters for updating message status"""

    message_id: str = Field(..., description="The message ID")
    location_id: str = Field(..., description="The location ID")
    status: MessageStatus = Field(..., description="New status for the message")
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


# Opportunity Tool Models


class GetOpportunitiesParams(BaseModel):
    """Parameters for getting opportunities"""

    location_id: str = Field(..., description="The location ID")
    pipeline_id: Optional[str] = Field(None, description="Filter by pipeline ID")
    pipeline_stage_id: Optional[str] = Field(
        None, description="Filter by pipeline stage ID"
    )
    assigned_to: Optional[str] = Field(None, description="Filter by assigned user ID")
    status: Optional[OpportunityStatus] = Field(None, description="Filter by status")
    contact_id: Optional[str] = Field(None, description="Filter by contact ID")
    query: Optional[str] = Field(None, description="Search query for opportunity name")
    limit: int = Field(100, description="Number of results to return", ge=1, le=100)
    skip: int = Field(0, description="Number of results to skip", ge=0)
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class GetOpportunityParams(BaseModel):
    """Parameters for getting a single opportunity"""

    opportunity_id: str = Field(..., description="The opportunity ID")
    location_id: str = Field(..., description="The location ID")
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class CreateOpportunityParams(BaseModel):
    """Parameters for creating an opportunity"""

    location_id: str = Field(..., description="The location ID")
    pipeline_id: str = Field(
        ..., description="Pipeline ID where the opportunity will be created"
    )
    name: str = Field(..., description="Opportunity name")
    pipeline_stage_id: str = Field(..., description="Pipeline stage ID")
    contact_id: str = Field(
        ..., description="Contact ID associated with the opportunity"
    )
    status: Optional[OpportunityStatus] = Field(
        default=OpportunityStatus.OPEN, description="Opportunity status"
    )
    monetary_value: Optional[float] = Field(
        None, description="Monetary value of the opportunity"
    )
    assigned_to: Optional[str] = Field(None, description="User ID of the assigned user")
    source: Optional[str] = Field(None, description="Source of the opportunity")
    notes: Optional[str] = Field(None, description="Notes about the opportunity")
    custom_fields: Optional[Dict[str, Any]] = Field(
        None, description="Custom field values"
    )
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class UpdateOpportunityParams(BaseModel):
    """Parameters for updating an opportunity"""

    opportunity_id: str = Field(..., description="The opportunity ID")
    location_id: str = Field(..., description="The location ID")
    name: Optional[str] = Field(None, description="Opportunity name")
    pipeline_stage_id: Optional[str] = Field(None, description="Pipeline stage ID")
    status: Optional[OpportunityStatus] = Field(None, description="Opportunity status")
    monetary_value: Optional[float] = Field(
        None, description="Monetary value of the opportunity"
    )
    assigned_to: Optional[str] = Field(None, description="User ID of the assigned user")
    source: Optional[str] = Field(None, description="Source of the opportunity")
    notes: Optional[str] = Field(None, description="Notes about the opportunity")
    custom_fields: Optional[Dict[str, Any]] = Field(
        None, description="Custom field values"
    )
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class DeleteOpportunityParams(BaseModel):
    """Parameters for deleting an opportunity"""

    opportunity_id: str = Field(..., description="The opportunity ID")
    location_id: str = Field(..., description="The location ID")
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class UpdateOpportunityStatusParams(BaseModel):
    """Parameters for updating opportunity status"""

    opportunity_id: str = Field(..., description="The opportunity ID")
    location_id: str = Field(..., description="The location ID")
    status: OpportunityStatus = Field(..., description="New status for the opportunity")
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class GetPipelinesParams(BaseModel):
    """Parameters for getting pipelines"""

    location_id: str = Field(..., description="The location ID")
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class GetPipelineParams(BaseModel):
    """Parameters for getting a single pipeline"""

    pipeline_id: str = Field(..., description="The pipeline ID")
    location_id: str = Field(..., description="The location ID")
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class GetPipelineStagesParams(BaseModel):
    """Parameters for getting pipeline stages"""

    pipeline_id: str = Field(..., description="The pipeline ID")
    location_id: str = Field(..., description="The location ID")
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


# Calendar Tool Models


class GetAppointmentsParams(BaseModel):
    """Parameters for getting appointments"""

    calendar_id: str = Field(..., description="The calendar ID")
    location_id: str = Field(..., description="The location ID")
    limit: int = Field(100, description="Number of results to return", ge=1, le=100)
    skip: int = Field(0, description="Number of results to skip", ge=0)
    start_date: Optional[str] = Field(None, description="Start date filter (YYYY-MM-DD)")
    end_date: Optional[str] = Field(None, description="End date filter (YYYY-MM-DD)")
    user_id: Optional[str] = Field(None, description="Filter by user ID")
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class GetAppointmentParams(BaseModel):
    """Parameters for getting a single appointment"""

    appointment_id: str = Field(..., description="The appointment ID")
    location_id: str = Field(..., description="The location ID")
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class CreateAppointmentParams(BaseModel):
    """Parameters for creating an appointment"""

    location_id: str = Field(..., description="The location ID")
    calendar_id: str = Field(..., description="The calendar ID")
    contact_id: str = Field(..., description="The contact ID")
    start_time: str = Field(..., description="Start time (ISO 8601 format)")
    end_time: str = Field(..., description="End time (ISO 8601 format)")
    title: Optional[str] = Field(None, description="Appointment title")
    appointment_status: Optional[str] = Field(None, description="Appointment status")
    assigned_user_id: Optional[str] = Field(None, description="Assigned user ID")
    notes: Optional[str] = Field(None, description="Appointment notes")
    address: Optional[str] = Field(None, description="Appointment address")
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class UpdateAppointmentParams(BaseModel):
    """Parameters for updating an appointment"""

    appointment_id: str = Field(..., description="The appointment ID")
    location_id: str = Field(..., description="The location ID")
    start_time: Optional[str] = Field(None, description="Start time (ISO 8601 format)")
    end_time: Optional[str] = Field(None, description="End time (ISO 8601 format)")
    title: Optional[str] = Field(None, description="Appointment title")
    appointment_status: Optional[str] = Field(None, description="Appointment status")
    assigned_user_id: Optional[str] = Field(None, description="Assigned user ID")
    notes: Optional[str] = Field(None, description="Appointment notes")
    address: Optional[str] = Field(None, description="Appointment address")
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class DeleteAppointmentParams(BaseModel):
    """Parameters for deleting an appointment"""

    appointment_id: str = Field(..., description="The appointment ID")
    location_id: str = Field(..., description="The location ID")
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class GetCalendarsParams(BaseModel):
    """Parameters for getting calendars"""

    location_id: str = Field(..., description="The location ID")
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class GetCalendarParams(BaseModel):
    """Parameters for getting a single calendar"""

    calendar_id: str = Field(..., description="The calendar ID")
    location_id: str = Field(..., description="The location ID")
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


class GetFreeSlotsParams(BaseModel):
    """Parameters for getting free time slots"""

    calendar_id: str = Field(..., description="The calendar ID")
    location_id: str = Field(..., description="The location ID")
    start_date: str = Field(..., description="Start date (YYYY-MM-DD)")
    end_date: Optional[str] = Field(None, description="End date (YYYY-MM-DD)")
    timezone: Optional[str] = Field(None, description="Timezone for the slots")
    access_token: Optional[str] = Field(
        None, description="Optional access token to use instead of stored token"
    )


# Helper function to get client with optional token override
async def get_client(access_token: Optional[str] = None) -> GoHighLevelClient:
    """Get GHL client with optional token override"""
    # Ensure clients are initialized
    if oauth_service is None or ghl_client is None:
        raise RuntimeError(
            "MCP server not properly initialized. Please restart the server."
        )

    if access_token:
        # Create a temporary client with the provided token
        temp_oauth = OAuthService()

        # Create an async function that returns the token
        async def return_token() -> str:
            return access_token

        temp_oauth.get_valid_token = return_token  # type: ignore
        return GoHighLevelClient(temp_oauth)
    return ghl_client


# Tools


@mcp.tool()
async def create_contact(params: CreateContactParams) -> Dict[str, Any]:
    """Create a new contact in GoHighLevel"""
    client = await get_client(params.access_token)

    contact_data = ContactCreate(
        locationId=params.location_id,
        firstName=params.first_name,
        lastName=params.last_name,
        email=params.email,
        phone=params.phone,
        tags=params.tags,
        source=params.source,
        companyName=params.company_name,
        address1=params.address,
        city=params.city,
        state=params.state,
        postalCode=params.postal_code,
        customFields=[
            {"key": k, "value": v} for k, v in (params.custom_fields or {}).items()
        ],
    )

    contact = await client.create_contact(contact_data)
    return {"success": True, "contact": contact.model_dump()}


@mcp.tool()
async def update_contact(params: UpdateContactParams) -> Dict[str, Any]:
    """Update an existing contact in GoHighLevel"""
    client = await get_client(params.access_token)

    update_data = ContactUpdate(
        firstName=params.first_name,
        lastName=params.last_name,
        email=params.email,
        phone=params.phone,
        tags=params.tags,
        companyName=params.company_name,
        address1=params.address,
        city=params.city,
        state=params.state,
        postalCode=params.postal_code,
        customFields=(
            [{"key": k, "value": v} for k, v in (params.custom_fields or {}).items()]
            if params.custom_fields
            else None
        ),
    )

    contact = await client.update_contact(
        params.contact_id, update_data, params.location_id
    )
    return {"success": True, "contact": contact.model_dump()}


@mcp.tool()
async def delete_contact(params: DeleteContactParams) -> Dict[str, Any]:
    """Delete a contact from GoHighLevel"""
    client = await get_client(params.access_token)

    success = await client.delete_contact(params.contact_id, params.location_id)
    return {
        "success": success,
        "message": (
            "Contact deleted successfully" if success else "Failed to delete contact"
        ),
    }


@mcp.tool()
async def get_contact(params: GetContactParams) -> Dict[str, Any]:
    """Get a single contact by ID"""
    client = await get_client(params.access_token)

    contact = await client.get_contact(params.contact_id, params.location_id)
    return {"success": True, "contact": contact.model_dump()}


@mcp.tool()
async def search_contacts(params: SearchContactsParams) -> Dict[str, Any]:
    """Search contacts in a location"""
    client = await get_client(params.access_token)

    result = await client.get_contacts(
        location_id=params.location_id,
        limit=params.limit,
        skip=params.skip,
        query=params.query,
        email=params.email,
        phone=params.phone,
        tags=params.tags,
    )

    return {
        "success": True,
        "contacts": [c.model_dump() for c in result.contacts],
        "count": result.count,
        "total": result.total,
    }


@mcp.tool()
async def add_contact_tags(params: ManageTagsParams) -> Dict[str, Any]:
    """Add tags to a contact"""
    client = await get_client(params.access_token)

    contact = await client.add_contact_tags(
        params.contact_id, params.tags, params.location_id
    )
    return {"success": True, "contact": contact.model_dump()}


@mcp.tool()
async def remove_contact_tags(params: ManageTagsParams) -> Dict[str, Any]:
    """Remove tags from a contact"""
    client = await get_client(params.access_token)

    contact = await client.remove_contact_tags(
        params.contact_id, params.tags, params.location_id
    )
    return {"success": True, "contact": contact.model_dump()}


# Conversation Tools


@mcp.tool()
async def get_conversations(params: GetConversationsParams) -> Dict[str, Any]:
    """Get conversations for a location"""
    client = await get_client(params.access_token)

    result = await client.get_conversations(
        location_id=params.location_id,
        limit=params.limit,
        skip=params.skip,
        contact_id=params.contact_id,
        starred=params.starred,
        unread_only=params.unread_only,
    )

    return {
        "success": True,
        "conversations": [c.model_dump() for c in result.conversations],
        "count": result.count,
        "total": result.total,
    }


@mcp.tool()
async def get_conversation(params: GetConversationParams) -> Dict[str, Any]:
    """Get a single conversation"""
    client = await get_client(params.access_token)

    conversation = await client.get_conversation(
        params.conversation_id, params.location_id
    )
    return {"success": True, "conversation": conversation.model_dump()}


@mcp.tool()
async def create_conversation(params: CreateConversationParams) -> Dict[str, Any]:
    """Create a new conversation"""
    client = await get_client(params.access_token)

    conversation_data = ConversationCreate(
        locationId=params.location_id,
        contactId=params.contact_id,
        lastMessageType=(
            MessageType(params.message_type) if params.message_type else None
        ),
    )

    conversation = await client.create_conversation(conversation_data)
    return {"success": True, "conversation": conversation.model_dump()}


@mcp.tool()
async def get_messages(params: GetMessagesParams) -> Dict[str, Any]:
    """Get messages from a conversation"""
    client = await get_client(params.access_token)

    result = await client.get_messages(
        conversation_id=params.conversation_id,
        location_id=params.location_id,
        limit=params.limit,
        skip=params.skip,
    )

    return {
        "success": True,
        "messages": [m.model_dump() for m in result.messages],
        "count": result.count,
        "total": result.total,
    }


@mcp.tool()
async def send_message(params: SendMessageParams) -> Dict[str, Any]:
    """Send a message in a conversation"""
    client = await get_client(params.access_token)

    message_data = MessageCreate(
        type=params.message_type,
        contactId=params.contact_id,
        message=params.message,
        phone=params.phone,
        html=params.html,
        text=params.text,
        subject=params.subject,
        attachments=params.attachments,
    )

    message = await client.send_message(
        conversation_id=params.conversation_id,
        message=message_data,
        location_id=params.location_id,
    )

    return {"success": True, "message": message.model_dump()}


@mcp.tool()
async def update_message_status(params: UpdateMessageStatusParams) -> Dict[str, Any]:
    """Update the status of a message"""
    client = await get_client(params.access_token)

    message = await client.update_message_status(
        message_id=params.message_id,
        status=params.status,
        location_id=params.location_id,
    )

    return {"success": True, "message": message.model_dump()}


# Opportunity Tools


@mcp.tool()
async def get_opportunities(params: GetOpportunitiesParams) -> Dict[str, Any]:
    """Get opportunities for a location"""
    client = await get_client(params.access_token)

    # Build filters
    filters = OpportunitySearchFilters(
        pipelineId=params.pipeline_id,
        pipelineStageId=params.pipeline_stage_id,
        assignedTo=params.assigned_to,
        status=params.status,
        contactId=params.contact_id,
        startDate=None,
        endDate=None,
        query=params.query,
    )

    result = await client.get_opportunities(
        location_id=params.location_id,
        limit=params.limit,
        skip=params.skip,
        filters=filters,
    )

    return {
        "success": True,
        "opportunities": [o.model_dump() for o in result.opportunities],
        "count": result.count,
        "total": result.total,
    }


@mcp.tool()
async def get_opportunity(params: GetOpportunityParams) -> Dict[str, Any]:
    """Get a single opportunity by ID"""
    client = await get_client(params.access_token)

    opportunity = await client.get_opportunity(
        params.opportunity_id, params.location_id
    )
    return {"success": True, "opportunity": opportunity.model_dump()}


@mcp.tool()
async def create_opportunity(params: CreateOpportunityParams) -> Dict[str, Any]:
    """Create a new opportunity in GoHighLevel"""
    client = await get_client(params.access_token)

    opportunity_data = OpportunityCreate(
        pipelineId=params.pipeline_id,
        locationId=params.location_id,
        name=params.name,
        pipelineStageId=params.pipeline_stage_id,
        status=params.status or OpportunityStatus.OPEN,
        contactId=params.contact_id,
        monetaryValue=params.monetary_value,
        assignedTo=params.assigned_to,
        source=params.source,
        notes=params.notes,
        customFields=(
            [{"key": k, "value": v} for k, v in (params.custom_fields or {}).items()]
            if params.custom_fields
            else None
        ),
    )

    opportunity = await client.create_opportunity(opportunity_data)
    return {"success": True, "opportunity": opportunity.model_dump()}


@mcp.tool()
async def update_opportunity(params: UpdateOpportunityParams) -> Dict[str, Any]:
    """Update an existing opportunity in GoHighLevel"""
    client = await get_client(params.access_token)

    update_data = OpportunityUpdate(
        locationId=params.location_id,
        name=params.name,
        pipelineStageId=params.pipeline_stage_id,
        status=params.status,
        monetaryValue=params.monetary_value,
        assignedTo=params.assigned_to,
        source=params.source,
        notes=params.notes,
        customFields=(
            [{"key": k, "value": v} for k, v in (params.custom_fields or {}).items()]
            if params.custom_fields
            else None
        ),
    )

    opportunity = await client.update_opportunity(
        params.opportunity_id, update_data, params.location_id
    )
    return {"success": True, "opportunity": opportunity.model_dump()}


@mcp.tool()
async def delete_opportunity(params: DeleteOpportunityParams) -> Dict[str, Any]:
    """Delete an opportunity from GoHighLevel"""
    client = await get_client(params.access_token)

    success = await client.delete_opportunity(params.opportunity_id, params.location_id)
    return {
        "success": success,
        "message": (
            "Opportunity deleted successfully"
            if success
            else "Failed to delete opportunity"
        ),
    }


@mcp.tool()
async def update_opportunity_status(
    params: UpdateOpportunityStatusParams,
) -> Dict[str, Any]:
    """Update the status of an opportunity"""
    client = await get_client(params.access_token)

    opportunity = await client.update_opportunity_status(
        opportunity_id=params.opportunity_id,
        status=params.status,
        location_id=params.location_id,
    )

    return {"success": True, "opportunity": opportunity.model_dump()}


# Pipeline Tools


@mcp.tool()
async def get_pipelines(params: GetPipelinesParams) -> Dict[str, Any]:
    """Get all pipelines for a location"""
    client = await get_client(params.access_token)

    pipelines = await client.get_pipelines(params.location_id)
    return {
        "success": True,
        "pipelines": [p.model_dump() for p in pipelines],
        "count": len(pipelines),
    }


@mcp.tool()
async def get_pipeline(params: GetPipelineParams) -> Dict[str, Any]:
    """Get a single pipeline by ID"""
    client = await get_client(params.access_token)

    pipeline = await client.get_pipeline(params.pipeline_id, params.location_id)
    return {"success": True, "pipeline": pipeline.model_dump()}


@mcp.tool()
async def get_pipeline_stages(params: GetPipelineStagesParams) -> Dict[str, Any]:
    """Get stages for a specific pipeline"""
    client = await get_client(params.access_token)

    stages = await client.get_pipeline_stages(params.pipeline_id, params.location_id)
    return {
        "success": True,
        "stages": [s.model_dump() for s in stages],
        "count": len(stages),
    }


@mcp.tool()
async def debug_config() -> Dict[str, Any]:
    """Debug tool to show current MCP server configuration and auth status"""
    import os
    from pathlib import Path

    if oauth_service is None:
        return {"error": "OAuth service not initialized"}

    # Use absolute paths based on module location
    project_root = Path(__file__).parent.parent
    cwd = Path.cwd()
    env_file = project_root / ".env"
    tokens_file = project_root / "config" / "tokens.json"
    standard_config_file = project_root / "config" / "standard_config.json"

    # Check token validity
    token_status = "unknown"
    token_expires_at = None
    if tokens_file.exists():
        try:
            import json
            from datetime import datetime

            with open(tokens_file) as f:
                token_data = json.load(f)
            expires_at = datetime.fromisoformat(
                token_data["expires_at"].replace("Z", "+00:00")
            )
            now = datetime.now(expires_at.tzinfo)
            token_status = "valid" if expires_at > now else "expired"
            token_expires_at = token_data["expires_at"]
        except Exception as e:
            token_status = f"error: {e}"

    return {
        "environment": {
            "working_directory": str(cwd),
            "project_root": str(project_root),
            "python_executable": sys.executable,
            "auth_mode_env_var": os.environ.get("AUTH_MODE", "NOT_SET"),
            "ghl_client_id_env_var": (
                os.environ.get("GHL_CLIENT_ID", "NOT_SET")[:10] + "..."
                if os.environ.get("GHL_CLIENT_ID")
                else "NOT_SET"
            ),
        },
        "files": {
            "env_file_exists": env_file.exists(),
            "tokens_json_exists": tokens_file.exists(),
            "standard_config_json_exists": standard_config_file.exists(),
        },
        "oauth_service": {
            "auth_mode": str(oauth_service.settings.auth_mode),
            "ghl_client_id": (
                oauth_service.settings.ghl_client_id[:10] + "..."
                if oauth_service.settings.ghl_client_id
                else None
            ),
            "has_ghl_client_secret": bool(oauth_service.settings.ghl_client_secret),
            "supabase_url": oauth_service.settings.supabase_url,
            "has_supabase_access_key": bool(oauth_service.settings.supabase_access_key),
            "standard_auth_service_initialized": oauth_service._standard_auth
            is not None,
        },
        "token_status": {
            "custom_token_status": token_status,
            "custom_token_expires_at": token_expires_at,
        },
    }


# Calendar Tools


@mcp.tool()
async def get_appointments(params: GetAppointmentsParams) -> Dict[str, Any]:
    """Get appointments for a calendar"""
    client = await get_client(params.access_token)
    
    from datetime import date
    
    # Convert string dates to date objects if provided
    start_date = None
    end_date = None
    if params.start_date:
        start_date = date.fromisoformat(params.start_date)
    if params.end_date:
        end_date = date.fromisoformat(params.end_date)

    appointments = await client.get_appointments(
        calendar_id=params.calendar_id,
        location_id=params.location_id,
        limit=params.limit,
        skip=params.skip,
        start_date=start_date,
        end_date=end_date,
        user_id=params.user_id,
    )
    return {"success": True, "appointments": appointments.model_dump()}


@mcp.tool()
async def get_appointment(params: GetAppointmentParams) -> Dict[str, Any]:
    """Get a specific appointment"""
    client = await get_client(params.access_token)

    appointment = await client.get_appointment(
        params.appointment_id, params.location_id
    )
    return {"success": True, "appointment": appointment.model_dump()}


@mcp.tool()
async def create_appointment(params: CreateAppointmentParams) -> Dict[str, Any]:
    """Create a new appointment"""
    client = await get_client(params.access_token)
    
    from datetime import datetime

    # Parse ISO datetime strings
    start_time = datetime.fromisoformat(params.start_time.replace('Z', '+00:00'))
    end_time = datetime.fromisoformat(params.end_time.replace('Z', '+00:00'))

    appointment_data = AppointmentCreate(
        locationId=params.location_id,
        calendarId=params.calendar_id,
        contactId=params.contact_id,
        startTime=start_time,
        endTime=end_time,
        title=params.title,
        appointmentStatus=params.appointment_status,
        assignedUserId=params.assigned_user_id,
        notes=params.notes,
        address=params.address,
    )

    appointment = await client.create_appointment(appointment_data)
    return {"success": True, "appointment": appointment.model_dump()}


@mcp.tool()
async def update_appointment(params: UpdateAppointmentParams) -> Dict[str, Any]:
    """Update an existing appointment"""
    client = await get_client(params.access_token)
    
    from datetime import datetime

    # Parse ISO datetime strings if provided
    start_time = None
    end_time = None
    if params.start_time:
        start_time = datetime.fromisoformat(params.start_time.replace('Z', '+00:00'))
    if params.end_time:
        end_time = datetime.fromisoformat(params.end_time.replace('Z', '+00:00'))

    update_data = AppointmentUpdate(
        startTime=start_time,
        endTime=end_time,
        title=params.title,
        appointmentStatus=params.appointment_status,
        assignedUserId=params.assigned_user_id,
        notes=params.notes,
        address=params.address,
    )

    appointment = await client.update_appointment(
        params.appointment_id, update_data, params.location_id
    )
    return {"success": True, "appointment": appointment.model_dump()}


@mcp.tool()
async def delete_appointment(params: DeleteAppointmentParams) -> Dict[str, Any]:
    """Delete an appointment"""
    client = await get_client(params.access_token)

    success = await client.delete_appointment(
        params.appointment_id, params.location_id
    )
    return {"success": success}


@mcp.tool()
async def get_calendars(params: GetCalendarsParams) -> Dict[str, Any]:
    """Get all calendars for a location"""
    client = await get_client(params.access_token)

    calendars = await client.get_calendars(params.location_id)
    return {"success": True, "calendars": calendars.model_dump()}


@mcp.tool()
async def get_calendar(params: GetCalendarParams) -> Dict[str, Any]:
    """Get a specific calendar"""
    client = await get_client(params.access_token)

    calendar = await client.get_calendar(params.calendar_id, params.location_id)
    return {"success": True, "calendar": calendar.model_dump()}


@mcp.tool()
async def get_free_slots(params: GetFreeSlotsParams) -> Dict[str, Any]:
    """Get available time slots for a calendar"""
    client = await get_client(params.access_token)
    
    from datetime import date

    # Convert string dates to date objects
    start_date = date.fromisoformat(params.start_date)
    end_date = None
    if params.end_date:
        end_date = date.fromisoformat(params.end_date)

    slots = await client.get_free_slots(
        calendar_id=params.calendar_id,
        location_id=params.location_id,
        start_date=start_date,
        end_date=end_date,
        timezone=params.timezone,
    )
    return {"success": True, "slots": slots.model_dump()}


# Resources


@mcp.resource("contacts://{location_id}")
async def list_contacts_resource(location_id: str) -> str:
    """List all contacts for a location as a resource"""
    if ghl_client is None:
        raise RuntimeError(
            "MCP server not properly initialized. Please restart the server."
        )
    result = await ghl_client.get_contacts(location_id=location_id, limit=100)

    # Format contacts as readable text
    lines = [f"# Contacts for Location {location_id}\n"]
    lines.append(f"Total contacts: {result.total or result.count}\n")

    for contact in result.contacts:
        name = (
            contact.name
            or f"{contact.firstName or ''} {contact.lastName or ''}".strip()
            or "Unknown"
        )
        lines.append(f"\n## {name}")
        lines.append(f"- ID: {contact.id}")
        if contact.email:
            lines.append(f"- Email: {contact.email}")
        if contact.phone:
            lines.append(f"- Phone: {contact.phone}")
        if contact.tags:
            lines.append(f"- Tags: {', '.join(contact.tags)}")
        if contact.companyName:
            lines.append(f"- Company: {contact.companyName}")

    return "\n".join(lines)


@mcp.resource("contact://{location_id}/{contact_id}")
async def get_contact_resource(location_id: str, contact_id: str) -> str:
    """Get a single contact as a resource"""
    if ghl_client is None:
        raise RuntimeError(
            "MCP server not properly initialized. Please restart the server."
        )
    contact = await ghl_client.get_contact(contact_id, location_id)

    # Format contact as readable text
    name = (
        contact.name
        or f"{contact.firstName or ''} {contact.lastName or ''}".strip()
        or "Unknown"
    )
    lines = [f"# Contact: {name}\n"]
    lines.append(f"**ID:** {contact.id}")
    lines.append(f"**Location:** {contact.locationId}")

    if contact.email:
        lines.append(f"**Email:** {contact.email}")
    if contact.phone:
        lines.append(f"**Phone:** {contact.phone}")
    if contact.companyName:
        lines.append(f"**Company:** {contact.companyName}")
    if contact.tags:
        lines.append(f"**Tags:** {', '.join(contact.tags)}")
    if contact.source:
        lines.append(f"**Source:** {contact.source}")

    if contact.address1:
        address_parts = [contact.address1]
        if contact.city:
            address_parts.append(contact.city)
        if contact.state:
            address_parts.append(contact.state)
        if contact.postalCode:
            address_parts.append(contact.postalCode)
        lines.append(f"**Address:** {', '.join(address_parts)}")

    if contact.dateAdded:
        lines.append(f"**Added:** {contact.dateAdded}")
    if contact.lastActivity:
        lines.append(f"**Last Activity:** {contact.lastActivity}")

    return "\n".join(lines)


@mcp.resource("conversations://{location_id}")
async def list_conversations_resource(location_id: str) -> str:
    """List all conversations for a location as a resource"""
    if ghl_client is None:
        raise RuntimeError(
            "MCP server not properly initialized. Please restart the server."
        )
    result = await ghl_client.get_conversations(location_id=location_id, limit=100)

    # Format conversations as readable text
    lines = [f"# Conversations for Location {location_id}\n"]
    lines.append(f"Total conversations: {result.total or result.count}\n")

    for conv in result.conversations:
        contact_name = conv.contactName or conv.fullName or "Unknown"
        lines.append(f"\n## {contact_name}")
        lines.append(f"- ID: {conv.id}")
        lines.append(f"- Contact ID: {conv.contactId}")
        if conv.lastMessageBody:
            lines.append(f"- Last Message: {conv.lastMessageBody[:100]}...")
        if conv.lastMessageType:
            lines.append(f"- Last Message Type: {conv.lastMessageType}")
        if conv.unreadCount > 0:
            lines.append(f"- Unread: {conv.unreadCount}")
        if conv.starred:
            lines.append("- ‚≠ê Starred")

    return "\n".join(lines)


@mcp.resource("conversation://{location_id}/{conversation_id}")
async def get_conversation_resource(location_id: str, conversation_id: str) -> str:
    """Get a single conversation as a resource"""
    if ghl_client is None:
        raise RuntimeError(
            "MCP server not properly initialized. Please restart the server."
        )
    conversation = await ghl_client.get_conversation(conversation_id, location_id)
    messages = await ghl_client.get_messages(conversation_id, location_id, limit=50)

    # Format conversation as readable text
    contact_name = conversation.contactName or conversation.fullName or "Unknown"
    lines = [f"# Conversation with {contact_name}\n"]
    lines.append(f"**ID:** {conversation.id}")
    lines.append(f"**Contact:** {conversation.contactId}")
    lines.append(f"**Location:** {conversation.locationId}")

    if conversation.email:
        lines.append(f"**Email:** {conversation.email}")
    if conversation.phone:
        lines.append(f"**Phone:** {conversation.phone}")
    if conversation.unreadCount > 0:
        lines.append(f"**Unread Messages:** {conversation.unreadCount}")
    if conversation.starred:
        lines.append("**Status:** ‚≠ê Starred")

    lines.append(
        f"\n## Messages ({messages.count} of {messages.total or messages.count})\n"
    )

    for msg in messages.messages:
        direction = "‚Üí Sent" if msg.direction == "outbound" else "‚Üê Received"
        lines.append(f"### {msg.dateAdded} {direction}")
        lines.append(f"- Type: {msg.type}")
        lines.append(f"- Status: {msg.status}")
        lines.append(f"- Message: {msg.body}")
        if msg.attachments:
            lines.append(f"- Attachments: {len(msg.attachments)}")
        lines.append("")

    return "\n".join(lines)


@mcp.resource("opportunities://{location_id}")
async def list_opportunities_resource(location_id: str) -> str:
    """List all opportunities for a location as a resource"""
    if ghl_client is None:
        raise RuntimeError(
            "MCP server not properly initialized. Please restart the server."
        )

    # Build filters for open opportunities
    filters = OpportunitySearchFilters(
        pipelineId=None,
        pipelineStageId=None,
        assignedTo=None,
        status=OpportunityStatus.OPEN,
        contactId=None,
        startDate=None,
        endDate=None,
        query=None,
    )
    result = await ghl_client.get_opportunities(
        location_id=location_id, limit=100, filters=filters
    )

    # Format opportunities as readable text
    lines = [f"# Opportunities for Location {location_id}\n"]
    lines.append(f"Total opportunities: {result.total or result.count}\n")

    for opp in result.opportunities:
        lines.append(f"\n## {opp.name}")
        lines.append(f"- ID: {opp.id}")
        lines.append(f"- Status: {opp.status}")
        lines.append(f"- Contact ID: {opp.contactId}")
        if opp.monetaryValue:
            lines.append(f"- Value: ${opp.monetaryValue:,.2f}")
        if opp.assignedTo:
            lines.append(f"- Assigned To: {opp.assignedTo}")
        if opp.source:
            lines.append(f"- Source: {opp.source}")
        lines.append(f"- Pipeline ID: {opp.pipelineId}")
        lines.append(f"- Stage ID: {opp.pipelineStageId}")

    return "\n".join(lines)


@mcp.resource("opportunity://{location_id}/{opportunity_id}")
async def get_opportunity_resource(location_id: str, opportunity_id: str) -> str:
    """Get a single opportunity as a resource"""
    if ghl_client is None:
        raise RuntimeError(
            "MCP server not properly initialized. Please restart the server."
        )
    opportunity = await ghl_client.get_opportunity(opportunity_id, location_id)

    # Format opportunity as readable text
    lines = [f"# Opportunity: {opportunity.name}\n"]
    lines.append(f"**ID:** {opportunity.id}")
    lines.append(f"**Location:** {opportunity.locationId}")
    lines.append(f"**Status:** {opportunity.status}")
    lines.append(f"**Contact ID:** {opportunity.contactId}")

    if opportunity.monetaryValue:
        lines.append(f"**Value:** ${opportunity.monetaryValue:,.2f}")
    if opportunity.assignedTo:
        lines.append(f"**Assigned To:** {opportunity.assignedTo}")
    if opportunity.source:
        lines.append(f"**Source:** {opportunity.source}")
    if opportunity.notes:
        lines.append(f"**Notes:** {opportunity.notes}")

    lines.append(f"**Pipeline ID:** {opportunity.pipelineId}")
    lines.append(f"**Stage ID:** {opportunity.pipelineStageId}")

    if opportunity.createdAt:
        lines.append(f"**Created:** {opportunity.createdAt}")
    if opportunity.updatedAt:
        lines.append(f"**Updated:** {opportunity.updatedAt}")

    return "\n".join(lines)


@mcp.resource("pipelines://{location_id}")
async def list_pipelines_resource(location_id: str) -> str:
    """List all pipelines for a location as a resource"""
    if ghl_client is None:
        raise RuntimeError(
            "MCP server not properly initialized. Please restart the server."
        )
    pipelines = await ghl_client.get_pipelines(location_id)

    # Format pipelines as readable text
    lines = [f"# Pipelines for Location {location_id}\n"]
    lines.append(f"Total pipelines: {len(pipelines)}\n")

    for pipeline in pipelines:
        lines.append(f"\n## {pipeline.name}")
        lines.append(f"- ID: {pipeline.id}")
        lines.append(f"- Location: {pipeline.locationId}")

        # Get stages for this pipeline
        try:
            stages = await ghl_client.get_pipeline_stages(pipeline.id, location_id)
            if stages:
                lines.append(f"- Stages ({len(stages)}):")
                for stage in stages:
                    lines.append(
                        f"  - {stage.name} (ID: {stage.id}, Position: {stage.position})"
                    )
        except Exception:
            lines.append("- Stages: Unable to load")

    return "\n".join(lines)


@mcp.resource("calendars://{location_id}")
async def list_calendars_resource(location_id: str) -> str:
    """List all calendars for a location as a resource"""
    if ghl_client is None:
        raise RuntimeError(
            "MCP server not properly initialized. Please restart the server."
        )
    result = await ghl_client.get_calendars(location_id)

    # Format calendars as readable text
    lines = [f"# Calendars for Location {location_id}\n"]
    lines.append(f"Total calendars: {result.count}\n")

    for calendar in result.calendars:
        lines.append(f"\n## {calendar.name}")
        lines.append(f"- ID: {calendar.id}")
        lines.append(f"- Location: {calendar.locationId}")
        if calendar.description:
            lines.append(f"- Description: {calendar.description}")
        lines.append(f"- Widget Type: {calendar.widgetType}")
        lines.append(f"- Widget Slug: {calendar.widgetSlug}")
        if calendar.appointmentTitle:
            lines.append(f"- Appointment Title: {calendar.appointmentTitle}")

    return "\n".join(lines)


@mcp.resource("calendar://{location_id}/{calendar_id}")
async def get_calendar_resource(location_id: str, calendar_id: str) -> str:
    """Get a single calendar as a resource"""
    if ghl_client is None:
        raise RuntimeError(
            "MCP server not properly initialized. Please restart the server."
        )
    calendar = await ghl_client.get_calendar(calendar_id, location_id)

    # Format calendar as readable text
    lines = [f"# Calendar: {calendar.name}\n"]
    lines.append(f"- ID: {calendar.id}")
    lines.append(f"- Location: {calendar.locationId}")
    if calendar.description:
        lines.append(f"- Description: {calendar.description}")
    lines.append(f"- Widget Type: {calendar.widgetType}")
    lines.append(f"- Widget Slug: {calendar.widgetSlug}")
    if calendar.appointmentTitle:
        lines.append(f"- Appointment Title: {calendar.appointmentTitle}")

    return "\n".join(lines)


@mcp.resource("appointments://{location_id}/{calendar_id}")
async def list_appointments_resource(location_id: str, calendar_id: str) -> str:
    """List all appointments for a calendar as a resource"""
    if ghl_client is None:
        raise RuntimeError(
            "MCP server not properly initialized. Please restart the server."
        )
    result = await ghl_client.get_appointments(
        calendar_id=calendar_id, location_id=location_id, limit=100
    )

    # Format appointments as readable text
    lines = [f"# Appointments for Calendar {calendar_id}\n"]
    lines.append(f"Total appointments: {result.count}\n")

    for appointment in result.appointments:
        lines.append(f"\n## {appointment.title or 'Untitled Appointment'}")
        lines.append(f"- ID: {appointment.id}")
        lines.append(f"- Contact ID: {appointment.contactId}")
        if appointment.startTime:
            lines.append(f"- Start Time: {appointment.startTime}")
        if appointment.endTime:
            lines.append(f"- End Time: {appointment.endTime}")
        if appointment.appointmentStatus:
            lines.append(f"- Status: {appointment.appointmentStatus}")
        if appointment.assignedUserId:
            lines.append(f"- Assigned User: {appointment.assignedUserId}")
        if appointment.notes:
            lines.append(f"- Notes: {appointment.notes}")
        if appointment.address:
            lines.append(f"- Address: {appointment.address}")

    return "\n".join(lines)


@mcp.resource("appointment://{location_id}/{appointment_id}")
async def get_appointment_resource(location_id: str, appointment_id: str) -> str:
    """Get a single appointment as a resource"""
    if ghl_client is None:
        raise RuntimeError(
            "MCP server not properly initialized. Please restart the server."
        )
    appointment = await ghl_client.get_appointment(appointment_id, location_id)

    # Format appointment as readable text
    lines = [f"# Appointment: {appointment.title or 'Untitled'}\n"]
    lines.append(f"- ID: {appointment.id}")
    lines.append(f"- Calendar ID: {appointment.calendarId}")
    lines.append(f"- Contact ID: {appointment.contactId}")
    if appointment.startTime:
        lines.append(f"- Start Time: {appointment.startTime}")
    if appointment.endTime:
        lines.append(f"- End Time: {appointment.endTime}")
    if appointment.appointmentStatus:
        lines.append(f"- Status: {appointment.appointmentStatus}")
    if appointment.assignedUserId:
        lines.append(f"- Assigned User: {appointment.assignedUserId}")
    if appointment.notes:
        lines.append(f"- Notes: {appointment.notes}")
    if appointment.address:
        lines.append(f"- Address: {appointment.address}")

    return "\n".join(lines)


def main():
    """Main function with startup check and setup"""

    # Check if we're running in MCP mode (no TTY) vs manual mode (with TTY)
    is_mcp_mode = not sys.stdin.isatty()

    if is_mcp_mode:
        # MCP client mode - validate config silently, don't run interactive setup
        async def silent_check():
            async with StandardModeSetup() as setup:
                auth_valid, message = setup.check_auth_status()
                if not auth_valid:
                    print(
                        f"ERROR: {message}. Please run 'python -m src.main' manually to complete setup.",
                        file=sys.stderr,
                    )
                    return False

                # Try to validate existing config
                config_valid = await setup.validate_existing_config()
                if not config_valid:
                    print(
                        "ERROR: Configuration validation failed. Please run 'python -m src.main' manually to re-setup.",
                        file=sys.stderr,
                    )
                    return False

                return True

        setup_success = asyncio.run(silent_check())
        if not setup_success:
            sys.exit(1)
    else:
        # Manual mode - run full interactive setup if needed
        setup_result = asyncio.run(startup_check_and_setup())

        if setup_result == "exit_after_setup":
            # Standard mode setup completed successfully, exit gracefully
            sys.exit(0)
        elif setup_result == "exit_after_custom_setup":
            # Custom mode setup completed successfully, exit gracefully
            sys.exit(0)
        elif setup_result == "exit_after_custom_instructions":
            # Custom mode instructions shown, exit gracefully
            sys.exit(0)
        elif not setup_result:
            print("üõë Server startup failed due to setup failure.")
            sys.exit(1)

    # Initialize clients after successful setup
    initialize_clients()

    if not is_mcp_mode:
        print("üöÄ Starting MCP server...")
        print("   Ready to receive requests from your LLM!")
        print("   Press Ctrl+C to stop the server.\n")

    # Start the FastMCP server using its built-in run method
    mcp.run()


# Run the server
if __name__ == "__main__":
    main()